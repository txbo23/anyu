1.可变对象与不可变对象
可变对象：list、dictionary、set
不可变对象：tuple、数字、字符串、None（不能用作dict中的key；作为函数参数传递时相当于值传递）

2.Python 的函数返回多值其实就是返回一个tuple，在语法上，返回一个tuple 可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值

3.可变参数与关键字参数
可变参数：定义可变参数和定义list 或tuple 参数相比，仅仅在参数前面加了一个*号。可变参数在函数调用时自动组装为一个tuple
关键字参数：在参数前面加两个*号，如**kw
可变参数允许你传入0 个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0 个或任意个含参数名的参数，这些关键字参数在函数内
部自动组装为一个dict
关于参数组合：参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数  （为避免歧义，默认参数不能放在必选参数前面）
              eg: def func(a, b, c=0, *args, **kw)  注：对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的

4.使用递归函数需要注意防止栈溢出
计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。
由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出
解决：通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
      尾递归是指，在函数返回的时候，调用自身本身，并且，return 语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使
     递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况

5.dict
dict.keys() dict.values() dict.items()返回值类型分别是dict_keys,dict_values,dict_items而不是列表或其他常用类型
python2中：items（返回列表），iteritems（返回迭代器）

6.zip
zip([seql, …])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）

8.map、reduce
map:map()函数接收两个参数，一个是函数，一个是序列，map 将传入的函数依次作用到序列的每个元素，并把结果作为新的list 返回。
reduce:把一个函数作用在一个序列[x1,x2,x3...]上，这个函数必须接收两个参数，reduce 把结果继续和序列的下一个元素做累积计算

9.装饰器
接受一个函数作为参数，并返回一个函数。借助Python 的@语法，把decorator 置于函数的定义。
装饰器就是对原来函数、对象功能的扩展，，相当于对函数重新封装，重点需要理解的是装饰器中返回的是函数，而且装饰器所装饰器的对象也需要是可调用的。
Python 的decorator 可以用函数实现，也可以用类实现：有类装饰器的时候，可以让类的构造函数__init__()接受一个函数，然后重载一个__call__()并且返回一个函数，来达到装饰器的目的。

10.yield
某个函数包含了yield，这意味着这个函数已经是一个Generator.通过next()可以恢复Generator执行，直到下一个yield。
next()和send(msg)在一定意义上作用是相似的,send()可以传递yield的值,next()只能传递None。send(msg) 和 next() 的返回值比较特殊，是下一个yield表达式的参数(yield 5，则返回 5)。
next的作用是唤醒并继续执行 ；send的作用是唤醒并继续执行，发送一个信息到生成器内部
注意 生成器刚启动时(第一次调用)，请使用next()语句或是send(None)，不能直接发送一个非None的值，否则会报TypeError，因为没有yield语句来接收这个值。
     即第一次调用时必须先next()或send(None)，否则会报错
总结：
生成器（generator）能够迭代的关键是他有next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。
带有yield的函数不再是一个普通的函数，而是一个生成器generator，可用于迭代
yield是一个类似return 的关键字，迭代一次遇到yield的时候就返回yield后面或者右面的值。而且下一次迭代的时候，从上一次迭代遇到的yield后面的代码开始执行
send()和next()的区别就在于send可传递参数给yield表达式，这时候传递的参数就会作为yield表达式的值，而yield的参数是返回给调用者的值，也就是说send可以强行修改上一个yield表达式值。

11.生成器generator
可迭代对象，解决大量元素时列表占用内存的问题，循环过程中不断推算后续元素  
next()方法  yield关键字（在执行过程中，遇到yield 就中断，下次又继续执行）  
创建一个generator，有两种方式，第一种方法很简单，直接把一个列表生成式的[]中括号改为（）小括号，即生成器表达式
如果计算过程比较复杂，另一种使用yield关键字，此时函数名+（）就变成了生成器，即为生成器函数
要调用生成器产生新的元素，有三种方式：调用内置的next()方法；使用循环对生成器对象进行遍历（推荐）；调用生成器对象的send()方法
其中使用next()方法遍历生成器时，最后是以抛出一个StopIeration异常终止。使用循环遍历生成器时比较简洁，且最后不会抛出一个StopIeration异常。因此使用循环的方式遍历生成器的方式才是被推荐的。
next()会调用yield，但不给它传值；send()会调用yield，也会给它传值（该值将成为当前yield表达式的结果值）
注：
可作用于for循环的数据类型：
一类是集合数据类型，如list,tuple,dict,set,str等；一类是generator，包括生成器和带yield的generator function

12.迭代器、生成器
一个实现了iter方法的对象是可迭代的，一个实现next方法的对象是迭代器：Iterator。
可以直接作用于for 循环的对象统称为可迭代对象：Iterable，可用isinstance()判断一个对象是否为可Iterable对象
即：
迭代对象是指实现了__iter__与__next__方法的对象，而可迭代对象可以只实现__iter__方法，也可以两个都实现。有的可迭代对象的迭代对象就是它本身。
迭代器都有一个next成员方法，这个方法要么返回迭代的下一项，要么引起异常结束迭代。
注：
生成器都是Iterator对象，但list、dict、str虽然是Iterable（可迭代对象），却不是Iterator（迭代器）。
可迭代对象通过iter()转成迭代器对象，iter()实质上是调用对象的__iter__方法，通过返回值来获取迭代器。
eg：print(isinstance(s,Iterator))#判断是不是迭代器     print(isinstance(s,Iterable)) #判断是不是可迭代对象     
    print(isinstance(iter(s),Iterator)) #把可迭代对象转换为迭代器
总结：
1）凡是可作用于for循环的对象都是Iterable类型；
2）可迭代对象不一定被for循环执行，for循环之前，有一步会把可迭代对象转化成迭代器，可转化为迭代器的可迭代对象，才可以被for循环执行。
3）凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
4）集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
5）Python3的for循环本质上就是通过不断调用next()函数实现的
6）迭代器一定是迭代对象，迭代对象不一定是迭代器。
7）如果一个可迭代对象同时它的迭代对象又是它本身的话会导致一个问题，无法重复迭代 ck:https://blog.csdn.net/he_and/article/details/80712495
ck:https://www.cnblogs.com/wj-1314/p/8490822.html
Iterable、Iterator与Generator之间的关系：
A.生成器对象既是可迭代对象，也是迭代器；B.迭代器对象一定是可迭代对象，反之则不一定
C.迭代器、生成器和可迭代对象都可以用for循环去迭代，生成器和迭代器还可以被next()方函数调用并返回下一个值。

13.为什么list、dict、str等数据类型不是Iterator？
这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。
可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。
Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。

14.列表生成式
列表生成式是Python提供的一种生成列表的简洁形式，应用列表生成式可以快速生成一个新的list。它最主要的应用场景是：根据已存在的可迭代对象推导出一个新的list。
